# Claude Code 與 Cursor 協作指南 - 協作流程和分工規範

## 🤝 協作模式總覽

### 成功的協作模式
```yaml
Claude Code 角色:
  - 架構設計與規劃
  - 複雜問題解決
  - 文檔撰寫與整理
  - 代碼審查與優化
  - 專業代理調度
  
Cursor 角色:
  - 快速代碼實現
  - 重複性編碼任務
  - 局部代碼修改
  - 語法錯誤修復
  - 實時代碼補全
  
Serena Memory:
  - 跨會話狀態保持
  - 知識持久化
  - 專案連續性保證
  - 協作狀態同步
```

## 📋 標準協作流程

### Phase 1: 專案啟動與設計 (Claude Code主導)
```yaml
步驟1 - 需求分析:
  負責: Claude Code
  產出: 需求文檔、技術規格
  記錄: Serena Memory - 01_專案架構總覽.md
  
步驟2 - 架構設計:
  負責: Claude Code
  產出: 系統架構圖、技術選型
  審查: 人工確認
  
步驟3 - 任務分解:
  負責: Claude Code
  產出: 詳細任務清單、優先級
  工具: TodoWrite追蹤
```

### Phase 2: 核心開發 (協同工作)
```yaml
步驟4 - 基礎框架:
  負責: Claude Code
  內容: 
    - 專案結構建立
    - 核心模組設計
    - 介面定義
  
步驟5 - 功能實現:
  負責: Cursor
  內容:
    - 基於Claude設計實現功能
    - 快速迭代開發
    - 單元測試編寫
  協作: Claude Code提供指導
  
步驟6 - 代碼整合:
  負責: Claude Code
  內容:
    - 代碼審查
    - 重構優化
    - 整合測試
```

### Phase 3: 優化與部署 (Claude Code主導)
```yaml
步驟7 - 性能優化:
  負責: Claude Code + 專業代理
  內容:
    - 性能分析
    - 查詢優化
    - 架構調整
    
步驟8 - 部署準備:
  負責: Claude Code
  內容:
    - Docker化
    - CI/CD配置
    - 監控設置
    
步驟9 - 文檔完成:
  負責: Claude Code
  內容:
    - 技術文檔
    - API文檔
    - 部署指南
```

## 🔄 協作介面規範

### 1. 代碼交接標準
```python
# Claude Code 設計介面示例
class DataQualityValidator:
    """
    數據質量驗證器基類
    
    設計者: Claude Code
    實現者: Cursor
    版本: 1.0
    """
    
    def validate(self, data: pd.DataFrame) -> ValidationResult:
        """
        執行數據驗證
        
        參數:
            data: 待驗證數據
            
        返回:
            ValidationResult: 驗證結果
            
        實現要求:
            1. 處理空值
            2. 類型檢查
            3. 業務規則驗證
        """
        raise NotImplementedError("請在Cursor中實現")
```

### 2. 任務交接模板
```markdown
## 任務交接單

**任務ID**: TASK-001
**交接方向**: Claude Code → Cursor
**任務類型**: 功能實現

### 任務描述
實現用戶認證模組

### 輸入規格
- 用戶名: string, 3-20字符
- 密碼: string, 8-50字符
- 加密方式: bcrypt

### 輸出規格
- 成功: {token: string, user: object}
- 失敗: {error: string, code: number}

### 實現要求
1. 使用JWT token
2. Token有效期24小時
3. 支援refresh token
4. 記錄登入日誌

### 測試要求
- 單元測試覆蓋率 > 80%
- 包含邊界條件測試
- 性能測試: <100ms響應
```

### 3. Serena Memory 同步規範
```yaml
記憶文件更新時機:
  專案啟動時:
    創建: 01_專案架構總覽.md
    記錄: 技術選型、架構設計
    
  Claude完成設計:
    更新: 02_Claude_Code完成工作記錄.md
    記錄: 設計決策、任務分配
    
  Cursor開始實現:
    創建: 04_Cursor完成工作記錄.md
    記錄: 實現進度、問題記錄
    
  協作切換時:
    更新: 03_Claude_Cursor協作指南.md
    記錄: 交接內容、狀態同步
    
  階段完成時:
    創建: 05_Phase完成記錄.md
    記錄: 成果總結、下階段計劃
```

## 🛠️ 工具使用規範

### Claude Code 專用工具
```yaml
設計階段:
  - Task: 調用專業代理
  - TodoWrite: 任務規劃
  - Write: 文檔撰寫
  - MultiEdit: 批量重構
  
分析階段:
  - Grep/Glob: 代碼搜索
  - Read: 文件審查
  - Bash: 系統命令
  
優化階段:
  - Edit: 精確修改
  - Task: 性能分析代理
```

### Cursor 輔助功能
```yaml
編碼階段:
  - Copilot: 代碼補全
  - 快速修復: 語法錯誤
  - 重構工具: 局部優化
  
測試階段:
  - 測試運行器
  - 調試工具
  - 覆蓋率分析
```

## 📊 協作效果評估

### 成功案例分析

#### Veeva System 協作成果
```yaml
效率提升:
  設計時間: -60% (Claude架構預設)
  開發時間: -40% (Cursor快速實現)
  調試時間: -50% (雙向檢查)
  
質量提升:
  代碼質量: A+級
  測試覆蓋: 95%+
  性能達標: 100%
  
成本節省:
  開發成本: -45%
  維護成本: -30%
  總體ROI: 650%
```

### 協作最佳實踐

#### DO's (推薦做法)
1. ✅ Claude設計完整架構後再讓Cursor實現
2. ✅ 使用Serena Memory保持狀態同步
3. ✅ 明確定義介面和規格
4. ✅ Claude定期審查Cursor的實現
5. ✅ 專業代理處理專門任務

#### DON'Ts (避免做法)
1. ❌ 未設計就直接實現
2. ❌ 忽略記憶文件更新
3. ❌ 模糊的任務交接
4. ❌ 跳過代碼審查
5. ❌ 重複實現相同功能

## 🔍 問題解決指南

### 常見協作問題

#### 問題1: 狀態不同步
```yaml
症狀: Cursor不知道Claude的設計決策
解決: 
  1. 更新Serena Memory
  2. 提供完整上下文
  3. 使用任務交接單
```

#### 問題2: 實現偏離設計
```yaml
症狀: Cursor實現與架構不符
解決:
  1. Claude審查糾正
  2. 提供詳細規格
  3. 增加檢查點
```

#### 問題3: 重複工作
```yaml
症狀: 兩邊做同樣的事
解決:
  1. 明確分工界限
  2. 使用TodoWrite追蹤
  3. 及時溝通同步
```

## 📈 持續改進

### 協作優化建議

#### 短期改進 (立即可行)
1. **標準化模板**: 建立更多交接模板
2. **自動化同步**: 自動更新記憶文件
3. **狀態儀表板**: 實時顯示協作狀態

#### 長期改進 (未來發展)
1. **AI協作協議**: 制定標準協作API
2. **智能任務分配**: 基於能力自動分配
3. **協作效果分析**: ML分析最佳協作模式

## 🎯 協作成功關鍵

### 三大核心原則
1. **清晰分工**: 各司其職，發揮優勢
2. **狀態同步**: Serena Memory持續更新
3. **質量把關**: Claude審查，Cursor實現

### 協作公式
```
成功專案 = Claude設計力 + Cursor執行力 + Serena記憶力
```

---

**指南版本**: v2.0
**最後更新**: 2025-08-07
**適用專案**: 所有Claude Code與Cursor協作專案
**下次審查**: 2025-09-01